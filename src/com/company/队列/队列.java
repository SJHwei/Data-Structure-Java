package com.company.队列;

/**
 * @author ShiWei
 * @date 2021/2/27 - 8:08
 *
 * 1. 队列的说明:
 *    (1) 队列是一个有序列表, 可以用数组或是链表来实现.
 *    (2) 遵循先入先出的原则. 即: 先存入队列的数据要先取出, 后存入的要后取出.
 *    (3) 应用场景: 银行排队案例.
 *
 * 2. 数组模拟普通队列的思路分析:
 *    (1) 队列属性的思路分析:
 *        1> 一个数组;
 *        2> maxSize: 队列本身是有序列表, 若使用数组的结构来存储队列的数据, 则队列数组的声明中除了一个数组, 还要有一个maxSize, maxSize是该队列的最大容量;
 *        3> 两个变量front及rear: 因为队列的输出和输入是分别从前后端来处理, 因此需要两个变量front和rear分别记录队列前后端的下标. front会随着数据输出而改变, rear则是随着数据输入而改变.
 *    (2) 队列方法的思路分析: (将数据存入队列时称为addQueue, 该方法的处理需要两个步骤)
 *        1> 将尾指针后移: rear+1, 当front==rear时, 队列为空;
 *        2> 若尾指针rear小于队列的最大下标maxSize-1, 则将数据存入rear所指的数据元素中, 否则无法存入数据. 当rear==maxSize-1时, 则队列满.
 *
 * 3. 数组模拟普通队列有缺点: 该队列只能使用一次, 没有达到复用的效果, 所以要对其进行优化, 变为环形队列, 通过取模(%)的方式实现.
 *
 * 4. 数组模拟环形队列思路分析:
 *    (1) front变量的含义做一个调整: front就指向队列的第一个元素, 也就是说arr[front]就是队列的第一个元素, front的初始值=0;
 *    (2) rear变量的含义做一个调整: rear指向队列的最后一个元素的后一个位置. 因为希望空出一个空间作为约定, rear的初始值=0;
 *    (3) 当队列满时, 条件是: (rear + 1) % maxSize = front;
 *    (4) 当队列为空时, 条件是: rear == front;
 *    (5) (重点)队列中有效的数据个数是: (rear + maxSize - front) % maxSize.
 */
public class 队列 {
}
